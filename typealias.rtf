{\rtf1\ansi\ansicpg1252\cocoartf1561
{\fonttbl\f0\fswiss\fcharset0 ArialMT;\f1\fswiss\fcharset0 Helvetica;\f2\fnil\fcharset0 Menlo-Regular;
}
{\colortbl;\red255\green255\blue255;\red28\green30\blue36;\red255\green255\blue255;\red135\green134\blue154;
\red249\green249\blue249;\red34\green88\blue157;\red235\green236\blue237;\red244\green244\blue244;\red67\green67\blue67;
\red0\green0\blue120;\red234\green234\blue234;\red0\green0\blue0;\red37\green127\blue159;}
{\*\expandedcolortbl;;\cssrgb\c14510\c15686\c18824;\cssrgb\c100000\c100000\c100000;\cssrgb\c60000\c60000\c66667;
\cssrgb\c98039\c98039\c98039;\cssrgb\c16863\c42745\c67843;\cssrgb\c93725\c94118\c94510;\cssrgb\c96471\c96471\c96471;\cssrgb\c33333\c33333\c33333;
\cssrgb\c0\c0\c54510;\cssrgb\c93333\c93333\c93333;\cssrgb\c0\c0\c0;\cssrgb\c16863\c56863\c68627;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}
{\list\listtemplateid2\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid101\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid2}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}{\listoverride\listid2\listoverridecount0\ls2}}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\partightenfactor0

\f0\fs64 \cf2 \cb3 \expnd0\expndtw0\kerning0
Swift Typealias
\f1\b\fs32 \cf4 \cb1 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 In this article, you will learn about typealias and its use cases in Swift.\cb1 \
\pard\pardeftab720\partightenfactor0

\b0 \cf2 \
\pard\pardeftab720\partightenfactor0

\b\fs38\fsmilli19200 \cf2 \cb5 Table of Contents\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls1\ilvl0
\b0\fs32 \cf6 \cb5 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
What is a typealias?\cf2 \cb1 \
\ls1\ilvl0\cf6 \cb5 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
How to create a typealias?\cf2 \cb1 \
\ls1\ilvl0\cf6 \cb5 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
Typealias for built-in types\cf2 \cb1 \
\ls1\ilvl0\cf6 \cb5 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
Typealias for user defined types\cf2 \cb1 \
\ls1\ilvl0\cf6 \cb5 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
Typealias for complex types\cf2 \cb1 \
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 A type alias allows you to provide a new name for an existing {\field{\*\fldinst{HYPERLINK "https://www.programiz.com/swift-programming/data-types"}}{\fldrslt \cf6 data type}} into your program. After a type alias is declared, the aliased name can be used instead of the existing type throughout the program.\cb1 \
\cb3 Type alias do not create new types. They simply provide a new name to an existing type.\cb1 \
\cb3 The main purpose of 
\f2\fs27\fsmilli13760 \cb7 typealias
\f1\fs32 \cb3  is to make our code more readable, and clearer in context for human understanding.\cb1 \
\
\pard\pardeftab720\partightenfactor0

\b\fs51\fsmilli25600 \cf2 \cb3 How to create a typealias?\cb1 \
\pard\pardeftab720\partightenfactor0

\b0\fs32 \cf2 \cb3 It is declared using the keyword 
\f2\fs27\fsmilli13760 \cb7 typealias
\f1\fs32 \cb3  as:\cb1 \
\pard\pardeftab720\partightenfactor0

\f2\fs30 \cf2 \cb8 typealias name = existing type\
\pard\pardeftab720\partightenfactor0

\f1\fs32 \cf2 \cb3 In Swift, you can use 
\f2\fs27\fsmilli13760 \cb7 typealias
\f1\fs32 \cb3  for most types. They can be either:\cb1 \
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls2\ilvl0
\b\fs31\fsmilli15680 \cf9 \cb3 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
Built-in types
\b0\fs32 \cf2  (for.eg: String, Int)\cb1 \
\ls2\ilvl0
\b\fs31\fsmilli15680 \cf9 \cb3 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
User-defined types
\b0\fs32 \cf2  (for.e.g: class, struct, enum)\cb1 \
\ls2\ilvl0
\b\fs31\fsmilli15680 \cf9 \cb3 \kerning1\expnd0\expndtw0 {\listtext	\uc0\u8226 	}\expnd0\expndtw0\kerning0
Complex types
\b0\fs32 \cf2  (for e.g: closures)\cb1 \
\pard\pardeftab720\partightenfactor0
\cf2 \
\pard\pardeftab720\partightenfactor0

\b\fs51\fsmilli25600 \cf2 \cb3 Typealias for built-in types\cb1 \
\pard\pardeftab720\partightenfactor0

\b0\fs32 \cf2 \cb3 You can use typealias for all built in data Types as String, Int, Float etc.\cb1 \
\pard\pardeftab720\partightenfactor0

\b\fs31\fsmilli15680 \cf9 \cb3 For example:
\b0\fs32 \cf2 \cb1 \
\pard\pardeftab720\partightenfactor0

\f2\fs30 \cf2 \cb8 typealias StudentName = String\
\pard\pardeftab720\partightenfactor0

\f1\fs32 \cf2 \cb3 The above declaration allows StudentName to be used everywhere instead of 
\f2\fs27\fsmilli13760 \cb7 String
\f1\fs32 \cb3 . So, if you want to create a constant of type string but represents more like student name. You can do as:\cb1 \
\pard\pardeftab720\partightenfactor0

\f2\fs30 \cf2 \cb8 let name:StudentName = "Jack"\
\pard\pardeftab720\partightenfactor0

\f1\fs32 \cf2 \cb3 Without using typealias, you should declare constant of type string as:\cb1 \
\pard\pardeftab720\partightenfactor0

\f2\fs30 \cf2 \cb8 let name:String = "Jack"\
\pard\pardeftab720\partightenfactor0

\f1\fs32 \cf2 \cb3 Above both examples creates a constant of type 
\f2\fs27\fsmilli13760 \cb7 String
\f1\fs32 \cb3 . But declaring with 
\f2\fs27\fsmilli13760 \cb7 typealias
\f1\fs32 \cb3 , our code becomes more readable.\cb1 \
\
\pard\pardeftab720\partightenfactor0

\b\fs51\fsmilli25600 \cf2 \cb3 Typealias for user defined types\cb1 \
\pard\pardeftab720\partightenfactor0

\b0\fs32 \cf2 \
\
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 There are many cases when you need to create your own data type. Suppose you want to create a Type that represents Student, you can create it using a class as:\cb1 \
\pard\pardeftab720\partightenfactor0

\f2\fs30 \cf10 \cb11 class\cf2  \cf13 Student\cf2  \{\
\
\}\
\pard\pardeftab720\partightenfactor0

\f1\fs32 \cf2 \cb3 Now a group of students can be represented as an array as:\cb1 \
\pard\pardeftab720\partightenfactor0

\f2\fs30 \cf2 \cb8 var students:Array<Student> = []\
\pard\pardeftab720\partightenfactor0

\f1\fs32 \cf2 \cb3 The above declaration can be made more readable by creating your own type for 
\f2\fs27\fsmilli13760 \cb7 Array<Student>
\f1\fs32 \cb3  using 
\f2\fs27\fsmilli13760 \cb7 typealias
\f1\fs32 \cb3  as:\cb1 \
\pard\pardeftab720\partightenfactor0

\f2\fs30 \cf2 \cb8 typealias Students = Array<Student>\
\pard\pardeftab720\partightenfactor0

\f1\fs32 \cf2 \cb3 Now we can make our code more readable as:\cb1 \
\pard\pardeftab720\partightenfactor0

\f2\fs30 \cf2 \cb8 var students:Students = []\
\pard\pardeftab720\partightenfactor0

\f1\fs32 \cf2 \cb1 \
\pard\pardeftab720\partightenfactor0

\b\fs51\fsmilli25600 \cf2 \cb3 Typealias for complex types\cb1 \
\pard\pardeftab720\partightenfactor0

\b0\fs32 \cf2 \cb3 Lets analyze one more example. Suppose we have a method that takes a closure as an input parameter.\cb1 \
\cb3 Don't worry if you do not know about closures. Just think of it as a special type of function. We have explained it detail in the article: Swift closures.\cb1 \
\pard\pardeftab720\partightenfactor0

\f2\fs30 \cf2 \cb11 func someMethod(oncomp:(\cf13 Int\cf2 )->(\cf13 String\cf2 ))\{\
\
\}\
\pard\pardeftab720\partightenfactor0

\f1\fs32 \cf2 \cb3 The above example takes a closure as an input to 
\f2\fs27\fsmilli13760 \cb7 someMethod
\f1\fs32 \cb3 . The closure takes an 
\f2\fs27\fsmilli13760 \cb7 Int
\f1\fs32 \cb3  value and returns 
\f2\fs27\fsmilli13760 \cb7 String
\f1\fs32 \cb3 .\cb1 \
\cb3 You can see the use of 
\f2\fs27\fsmilli13760 \cb7 (Int)->(String)
\f1\fs32 \cb3  makes less sense to the reader. You can use 
\f2\fs27\fsmilli13760 \cb7 typealias
\f1\fs32 \cb3  to provide a new name for it:\cb1 \
\pard\pardeftab720\partightenfactor0

\f2\fs30 \cf2 \cb8 typealias CompletionHandler = (Int)->(String)\
\pard\pardeftab720\partightenfactor0

\f1\fs32 \cf2 \cb3 Now you can rewrite the method as:\cb1 \
\pard\pardeftab720\partightenfactor0

\f2\fs30 \cf2 \cb11 func someMethod(oncomp:\cf13 CompletionHandler\cf2 )\{\
\
\}\
\pard\pardeftab720\partightenfactor0

\f1\fs32 \cf2 \cb3 We can see the same code looks more clear and programmer friendly with the use of 
\f2\fs27\fsmilli13760 \cb7 typealias
\f1\fs32 \cb3 .}